import timeit

"""
Результаты тестов:

---------------------------------------------------------------
 метод            |  большое число,     |  небольшое число,
                  |  среднее время, с   |  среднее время, с
---------------------------------------------------------------
 isEven           | 0.08116133739968064 | 0.05592028949758969
 isEvenRefactored | 0.07661887470167131 | 0.05430217270331923
 isEvenBitwise    | 0.07404323119844776 | 0.07138502030284144
 
 Вывод: метод `isEvenBitwise` является наиболее быстродейственным при определении чётности
 больших чисел, но при этом показывает худший результат при небольших числах.
 
 Метод `isEvenRefactored` можно назвать универсальным, т.к. он показывает лучшие результаты
 (относительно метода `isEven`) как при больших, так и при малых значениях аргумента n.
"""

def isEven(n):
    """
    Оригинальный метод из задания (классический подход определения чётности).
    
    Преимущества:
      - понятный и хорошо читаемый "классический" метод.
    
    Недостатки:
      - можно улучшить производительность.
    """
    return n % 2 == 0

def isEvenRefactored(n):
    """
    Проведён рефакторинг оригинального метода, за счёт того, что в Python
    в контексте сравнений 0 принимается за значение False. Благодаря этому
    для сравнения можно использовать тернарный оператор, что незначительно
    ускоряет вычисление.

    Преимущества:
      - более производительный по сравнению с isEven;
      - показывает хорошую производительность как при больших, так и при
        малых значениях аргумента `n` (см. результат бенчмарка).
    
    Недостатки:
      - сложно читаемый неинтуитивный код.
    """
    return False if n % 2 else True

def isEvenBitwise(n):
    """
    Метод проверки чётности целочисленного числа с использованием побитовой операции "И".
    
    Описание: воспользуемя тернарным оператором, показанном в методе isEvenRefactored, но при
    этом для определения чётности будем использовать побитовую операцию "И": у чётных чисел
    младший бит установлен в 0, а у нечётных чисел - в 1, что позволяет проверить чётность
    числа без операции деления.

    Преимущества:
      - может быть более быстродейственным при определении чётности больших чисел.

    Недостатки:
      - сложно читаемый неинтуитивный код;
      - неэффективен при числах с небольшими значениями.
    """
    return False if n & 1 else True

# Тесты производительности:
def run_test(method_name, statement, setup, runs = 10):
    times = [timeit.timeit(statement, setup=setup) for _ in range(runs)]
    mean_time = sum(times) / len(times)
    print(f"{method_name} среднее время: {mean_time}")

print("Большое число:")
run_test("isEven", 'isEven(380_247_238_074)', 'from __main__ import isEven')
run_test("isEvenRefactored", 'isEvenRefactored(380_247_238_074)', 'from __main__ import isEvenRefactored')
run_test("isEvenBitwise", 'isEvenBitwise(380_247_238_074)', 'from __main__ import isEvenBitwise')

print("Небольшое число:")
run_test("isEven", 'isEven(223)', 'from __main__ import isEven')
run_test("isEvenRefactored", 'isEvenRefactored(223)', 'from __main__ import isEvenRefactored')
run_test("isEvenBitwise", 'isEvenBitwise(223)', 'from __main__ import isEvenBitwise')
